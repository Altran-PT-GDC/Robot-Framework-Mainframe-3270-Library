import os
import time
from datetime import timedelta
from typing import Any, Optional

# fmt: off
from robot.api import logger
from robot.api.deco import keyword
from robot.utils import secs_to_timestr, timestr_to_secs

# fmt: on
from Mainframe3270.librarycomponent import LibraryComponent


class X3270(LibraryComponent):
    def _convert_timeout(self, time):
        if isinstance(time, timedelta):
            return time.total_seconds()
        return timestr_to_secs(time, round_to=None)

    @keyword("Change Timeout")
    def change_timeout(self, seconds: timedelta) -> None:
        """
        Change the timeout for connection in seconds.

        Example:
            | Change Timeout | 3 seconds |
        """
        self.timeout = self._convert_timeout(seconds)

    @keyword("Change Wait Time")
    def change_wait_time(self, wait_time: timedelta) -> None:
        """To give time for the mainframe screen to be "drawn" and receive the next commands, a "wait time" has been
        created, which by default is set to 0.5 seconds. This is a sleep applied AFTER the following keywords:

        - `Execute Command`
        - `Send Enter`
        - `Send PF`
        - `Write`
        - `Write in position`

        If you want to change this value, just use this keyword passing the time in seconds.

        Example:
            | Change Wait Time | 0.5              |
            | Change Wait Time | 200 milliseconds |
            | Change Wait Time | 0:00:01.500      |
        """
        self.wait_time = self._convert_timeout(wait_time)

    @keyword("Change Wait Time After Write")
    def change_wait_time_after_write(self, wait_time_after_write: timedelta) -> None:
        """To give the user time to see what is happening inside the mainframe, a "wait time after write" has
        been created, which by default is set to 0 seconds. This is a sleep applied AFTER sending a string in these
        keywords:

        - `Write`
        - `Write Bare`
        - `Write in position`
        - `Write Bare in position`

        If you want to change this value, just use this keyword passing the time in seconds.

        Note: This keyword is useful for debug purpose

        Example:
            | Change Wait Time After Write | 1             |
            | Change Wait Time After Write | 0.5 seconds   |
            | Change Wait Time After Write | 0:00:02       |
        """
        self.wait_time_after_write = self._convert_timeout(wait_time_after_write)

    @keyword("Read")
    def read(self, ypos: int, xpos: int, length: int) -> str:
        """Get a string of ``length`` at screen co-ordinates ``ypos`` / ``xpos``.

        Co-ordinates are 1 based, as listed in the status area of the terminal.

        Example for read a string in the position y=8 / x=10 of a length 15:
            | ${value} | Read | 8 | 10 | 15 |
        """
        self._check_limits(ypos, xpos)
        # Checks if the user has passed a length that will be larger than the x limit of the screen.
        if (xpos + length) > (80 + 1):
            raise Exception(
                "You have exceeded the x-axis limit of the mainframe screen"
            )
        string = self.mf.string_get(ypos, xpos, length)
        return string

    @keyword("Read All Screen")
    def read_all_screen(self) -> str:
        """Read the current screen and returns all content in one string.

        This is useful if your automation scripts should take different routes depending
        on a message shown on the screen.

        Example:
            | ${screen} | Read All Screen              |
            | IF   | 'certain text' in '''${screen}''' |
            |      | Do Something                      |
            | ELSE |                                   |
            |      | Do Something Else                 |
            | END  |                                   |
        """
        return self._read_all_screen()

    @keyword("Execute Command")
    def execute_command(self, cmd: str) -> None:
        """Execute a [http://x3270.bgp.nu/wc3270-man.html#Actions|x3270 command].

        Example:
            | Execute Command | Enter |
            | Execute Command | Home |
            | Execute Command | Tab |
            | Execute Command | PF(1) |
        """
        self.mf.exec_command(cmd.encode("utf-8"))
        time.sleep(self.wait_time)

    @keyword("Set Screenshot Folder")
    def set_screenshot_folder(self, path: str) -> None:
        r"""Set a folder to keep the html files generated by the `Take Screenshot` keyword.

        Note that the folder needs to exist before running your automation scripts. Else the images
        will be stored in the ``${OUTPUT DIR}`` set by robotframework.

        Example:
            | Set Screenshot Folder | C:\\Temp\\Images |
        """
        if os.path.exists(os.path.normpath(os.path.join(self.output_folder, path))):
            self.img_folder = path
        else:
            logger.error(f'Given screenshots path "{path}" does not exist')
            logger.warn(f'Screenshots will be saved in "{self.img_folder}"')

    @keyword("Take Screenshot")
    def take_screenshot(
        self, height: int = 410, width: int = 670, filename_prefix: str = "screenshot"
    ) -> str:
        """Generate a screenshot of the IBM 3270 Mainframe in a html format. The
        default folder is the log folder of RobotFramework, if you want change see the `Set Screenshot Folder`.

        The Screenshot is printed in a iframe log, with the values of height=410 and width=670, you
        can change these values by passing them to the keyword.

        The file name prefix can be set, the default is "screenshot".

        The full file path is returned.

        Example:
            | ${filepath} | Take Screenshot |
            | ${filepath} | Take Screenshot | height=500 | width=700 |
            | Take Screenshot | height=500 | width=700 |
            | Take Screenshot | filename_prefix=MyScreenshot |
        """
        extension = "html"
        filename_sufix = round(time.time() * 1000)
        filepath = os.path.join(
            self.img_folder, "%s_%s.%s" % (filename_prefix, filename_sufix, extension)
        )
        self.mf.save_screen(os.path.join(self.output_folder, filepath))
        logger.write(
            '<iframe src="%s" height="%s" width="%s"></iframe>'
            % (filepath.replace("\\", "/"), height, width),
            level="INFO",
            html=True,
        )
        return filepath

    @keyword("Wait Field Detected")
    def wait_field_detected(self) -> None:
        """Wait until the screen is ready, the cursor has been positioned
        on a modifiable field, and the keyboard is unlocked.

        Sometimes the server will "unlock" the keyboard but the screen
        will not yet be ready.  In that case, an attempt to read or write to the
        screen will result in a 'E' keyboard status because we tried to read from
        a screen that is not ready yet.

        Using this method tells the client to wait until a field is
        detected and the cursor has been positioned on it.
        """
        self.mf.wait_for_field()

    @keyword("Delete Char")
    def delete_char(
        self, ypos: Optional[int] = None, xpos: Optional[int] = None
    ) -> None:
        """Delete the character under the cursor. If you want to delete a character that is in
        another position, simply pass the coordinates ``ypos`` / ``xpos``.

        Co-ordinates are 1 based, as listed in the status area of the
        terminal.

        Example:
            | Delete Char |
            | Delete Char | ypos=9 | xpos=25 |
        """
        if ypos is not None and xpos is not None:
            self.mf.move_to(ypos, xpos)
        self.mf.exec_command(b"Delete")

    @keyword("Delete Field")
    def delete_field(
        self, ypos: Optional[int] = None, xpos: Optional[int] = None
    ) -> None:
        """Delete the entire content of a field at the current cursor location and positions
        the cursor at beginning of field. If you want to delete a field that is in
        another position, simply pass the coordinates ``ypos`` / ``xpos`` of any part in the field.

        Co-ordinates are 1 based, as listed in the status area of the
        terminal.

        Example:
            | Delete Field |
            | Delete Field | ypos=12 | xpos=6 |
        """
        if ypos is not None and xpos is not None:
            self.mf.move_to(ypos, xpos)
        self.mf.delete_field()

    @keyword("Send Enter")
    def send_enter(self) -> None:
        """Send an Enter to the screen."""
        self.mf.send_enter()
        time.sleep(self.wait_time)

    @keyword("Move Next Field")
    def move_next_field(self) -> None:
        """Move the cursor to the next input field. Equivalent to pressing the Tab key."""
        self.mf.exec_command(b"Tab")

    @keyword("Move Previous Field")
    def move_previous_field(self) -> None:
        """Move the cursor to the previous input field. Equivalent to pressing the Shift+Tab keys."""
        self.mf.exec_command(b"BackTab")

    @keyword("Send PF")
    def send_PF(self, PF: str) -> None:
        """Send a Program Function to the screen.

        Example:
               | Send PF | 3 |
        """
        self.mf.exec_command(("PF({0})").format(PF).encode("utf-8"))
        time.sleep(self.wait_time)

    @keyword("Write")
    def write(self, txt: str) -> None:
        """Send a string *and Enter* to the screen at the current cursor location.

        Example:
            | Write | something |
        """
        self._write(txt, enter=1)

    @keyword("Write Bare")
    def write_bare(self, txt: str) -> None:
        """Send only the string to the screen at the current cursor location.

        Example:
            | Write Bare | something |
        """
        self._write(txt)

    @keyword("Write In Position")
    def write_in_position(self, txt: str, ypos: int, xpos: int) -> None:
        """Send a string *and Enter* to the screen at screen co-ordinates ``ypos`` / ``xpos``.

        Co-ordinates are 1 based, as listed in the status area of the
        terminal.

        Example:
            | Write in Position | something | 9 | 11 |
        """
        self._write(txt, ypos, xpos, enter=1)

    @keyword("Write Bare In Position")
    def write_bare_in_position(self, txt: str, ypos: int, xpos: int):
        """Send only the string to the screen at screen co-ordinates ``ypos`` / ``xpos``.

        Co-ordinates are 1 based, as listed in the status area of the
        terminal.

        Example:
            | Write Bare in Position | something | 9 | 11 |
        """
        self._write(txt, ypos, xpos)

    def _write(
        self,
        txt: Any,
        ypos: Optional[int] = None,
        xpos: Optional[int] = None,
        enter: int = 0,
    ) -> None:
        txt = txt.encode("unicode_escape")
        if ypos is not None and xpos is not None:
            self._check_limits(ypos, xpos)
            self.mf.send_string(txt, ypos, xpos)
        else:
            self.mf.send_string(txt)
        time.sleep(self.wait_time_after_write)
        for i in range(enter):
            self.mf.send_enter()
            time.sleep(self.wait_time)

    @keyword("Wait Until String")
    def wait_until_string(
        self, txt: str, timeout: timedelta = timedelta(seconds=5)
    ) -> str:
        """Wait until a string exists on the mainframe screen to perform the next step. If the string does not appear in
        5 seconds, the keyword will raise an exception. You can define a different timeout.

        Example:
            | Wait Until String | something |
            | Wait Until String | something | 10 |
            | Wait Until String | something | 15 s |
            | Wait Until String | something | 0:00:15 |
        """
        timeout = self._convert_timeout(timeout)
        max_time = time.time() + timeout  # type: ignore
        while time.time() < max_time:
            result = self._search_string(str(txt))
            if result:
                return txt
        raise Exception(f'String "{txt}" not found in {secs_to_timestr(timeout)}')

    def _search_string(self, string: str, ignore_case: bool = False) -> bool:
        """Search if a string exists on the mainframe screen and return True or False."""

        def __read_screen(string: str, ignore_case: bool) -> bool:
            for ypos in range(24):
                line = self.mf.string_get(ypos + 1, 1, 80)
                if ignore_case:
                    line = line.lower()
                if string in line:
                    return True
            return False

        status = __read_screen(string, ignore_case)
        return status

    def _read_all_screen(self) -> str:
        """Read all the mainframe screen and return in a single string."""
        full_text = ""
        for ypos in range(24):
            full_text += self.mf.string_get(ypos + 1, 1, 80)
        return full_text

    @staticmethod
    def _check_limits(ypos: int, xpos: int):
        """Checks if the user has passed some coordinate y / x greater than that existing in the mainframe"""
        if ypos > 24:
            raise Exception(
                "You have exceeded the y-axis limit of the mainframe screen"
            )
        if xpos > 80:
            raise Exception(
                "You have exceeded the x-axis limit of the mainframe screen"
            )
