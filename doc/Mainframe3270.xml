<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="Mainframe3270" type="LIBRARY" format="ROBOT" scope="SUITE" generated="2023-12-28T16:44:38+00:00" specversion="5" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\__init__.py" lineno="22">
<version>4.1</version>
<doc>Mainframe3270 is a library for Robot Framework based on the [https://pypi.org/project/py3270/|py3270 project],
a Python interface to x3270, an IBM 3270 terminal emulator. It provides an API to a x3270 or s3270 subprocess.

= Installation  =

To use this library, you must have the [http://x3270.bgp.nu/download.html|x3270 project] installed and included in your PATH.
On Windows, you can install wc3270 and add "C:\Program Files\wc3270" to your PATH in the Environment Variables.

= Example =

| *** Settings ***
| Library           Mainframe3270
|
| *** Test Cases ***
| Example
|     Open Connection    Hostname    LUname
|     Change Wait Time    0.4 seconds
|     Change Wait Time After Write    0.4 seconds
|     Set Screenshot Folder    C:\\Temp\\IMG
|     ${value}    Read    3    10    17
|     Page Should Contain String    ENTER APPLICATION
|     Wait Field Detected
|     Write Bare    applicationname
|     Send Enter
|     Take Screenshot
|     Close Connection

= Concurrent Connections =

The library allows you to have multiple sessions open at the same time. Each session opened by `Open Connection` or
`Open Connection From Session File` will return an index that can be used to reference it
when switching between connections using the `Switch Connection` keyword. The indices start from 1 and are incremented
by each newly opened connection. Calling `Close All Connection` will reset the index counter to 1.

Additionally, you can provide aliases to your sessions when opening a connection, and switch the connection
using that alias instead of the index.

It is worth noting that the connection that was opened last is always the current connection.

| *** Test Cases ***
| Concurrent Sessions
|     ${index_1}    Open Connection    Hostname    # this is the current connection
|     Write Bare    First String
|     ${index_2}    Open Connection    Hostname    alias=second    # 'second' is now the current connection
|     Write Bare    Second String
|     Switch Connection    ${index_1}    # swtiching the connection using the index
|     Page Should Contain String    First String
|     Switch Connection    second    # switchting the ocnnection using the alias
|     Page Should Contain String    Second String
|     [Teardown]    Close All Connections

= Changing the emulator model (experimental) =

By default, the library uses the emulator model 2, which is 24 rows by 80 columns.
You can, however, change the model globally when `importing` the library with the `model` argument
set to the model of your choice.

The basic models are 2, 3, 4, and 5. These models differ in their screen size as illustrated in this table:

| *3270 Model* | *Rows* | *Columns* |
| 2            | 24     | 80        |
| 3            | 32     | 80        |
| 4            | 43     | 80        |
| 5            | 27     | 132       |


They can be combined with the 3278 (monochrome green-screen) or 3279 (color) prefix, e.g. 3278-2 or 3279-2.

In addition to that, there is a -E suffix that indicates support for the [https://x3270.miraheze.org/wiki/3270_data_stream_protocol#extended|x3270 extended data stream].

You can find more information on emulator models on the [https://x3270.miraheze.org/wiki/3270_models|x3270 wiki].

In addition to setting the model globally, you can also set the model on the individual emulator basis by providing the model arguments to the `Open Connection`
or `Open Connection From Session File` keywords.

Here is an example for setting the emulator in the Open Connection keyword:

| Open Connection    pub400.com    extra_args=["-xrm", "*model: 4"]

And this is how you would set the emulator model in the Open Connection From Session File keyword:

| Open Connection From Session File    /path/to/session/file

Where the content of the session file would be

| *hostname: pub400.com
| *model: 4


Note that this is an experimental feature, so not all models might work as expected.</doc>
<tags>
</tags>
<inits>
<init name="__init__" lineno="119">
<arguments repr="visible: bool = True, timeout: timedelta = 0:00:30, wait_time: timedelta = 0:00:00.500000, wait_time_after_write: timedelta = 0:00:00, img_folder: str = ., run_on_failure_keyword: str = Take Screenshot, model: str = 2">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="visible: bool = True">
<name>visible</name>
<type name="bool" typedoc="boolean">bool</type>
<default>True</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta = 0:00:30">
<name>timeout</name>
<type name="timedelta" typedoc="timedelta">timedelta</type>
<default>0:00:30</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="wait_time: timedelta = 0:00:00.500000">
<name>wait_time</name>
<type name="timedelta" typedoc="timedelta">timedelta</type>
<default>0:00:00.500000</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="wait_time_after_write: timedelta = 0:00:00">
<name>wait_time_after_write</name>
<type name="timedelta" typedoc="timedelta">timedelta</type>
<default>0:00:00</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="img_folder: str = .">
<name>img_folder</name>
<type name="str" typedoc="string">str</type>
<default>.</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="run_on_failure_keyword: str = Take Screenshot">
<name>run_on_failure_keyword</name>
<type name="str" typedoc="string">str</type>
<default>Take Screenshot</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="model: str = 2">
<name>model</name>
<type name="str" typedoc="string">str</type>
<default>2</default>
</arg>
</arguments>
<doc>By default, the emulator visibility is set to visible=True.
In this case test cases are executed using wc3270 (Windows) or x3270 (Linux/MacOSX).
You can change this by setting visible=False.
Then test cases are run using ws3720 (Windows) or s3270 (Linux/MacOS).
This is useful when test cases are run in a CI/CD-pipeline and there is no need for a graphical user interface.

Timeout, waits and screenshot folder are set on library import as shown above.
However, they can be changed during runtime. To modify the ``wait_time``, see `Change Wait Time`,
to modify the ``img_folder``, see `Set Screenshot Folder`,
and to modify the ``timeout``, see the `Change Timeout` keyword. Timeouts support all available
Robot Framework [https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#time-format|time formats].

By default, Mainframe3270 will take a screenshot on failure.
You can overwrite this to run any other keyword by setting the ``run_on_failure_keyword`` option.
If you pass ``None`` to this argument, no keyword will be run.
To change the ``run_on_failure_keyword`` during runtime, see `Register Run On Failure Keyword`.</doc>
<shortdoc>By default, the emulator visibility is set to visible=True. In this case test cases are executed using wc3270 (Windows) or x3270 (Linux/MacOSX). You can change this by setting visible=False. Then test cases are run using ws3720 (Windows) or s3270 (Linux/MacOS). This is useful when test cases are run in a CI/CD-pipeline and there is no need for a graphical user interface.</shortdoc>
</init>
</inits>
<keywords>
<kw name="Change Timeout" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\wait_and_timeout.py" lineno="11">
<arguments repr="seconds: timedelta">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="seconds: timedelta">
<name>seconds</name>
<type name="timedelta" typedoc="timedelta">timedelta</type>
</arg>
</arguments>
<doc>Change the timeout for connection in seconds.

Example:
    | Change Timeout | 3 seconds |</doc>
<shortdoc>Change the timeout for connection in seconds.</shortdoc>
</kw>
<kw name="Change Wait Time" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\wait_and_timeout.py" lineno="21">
<arguments repr="wait_time: timedelta">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="wait_time: timedelta">
<name>wait_time</name>
<type name="timedelta" typedoc="timedelta">timedelta</type>
</arg>
</arguments>
<doc>To give time for the mainframe screen to be "drawn" and receive the next commands, a "wait time" has been
created, which by default is set to 0.5 seconds. This is a sleep applied AFTER the following keywords:

- `Execute Command`
- `Send Enter`
- `Send PF`
- `Write`
- `Write in position`

If you want to change this value, just use this keyword passing the time in seconds.

Example:
    | Change Wait Time | 0.5 |
    | Change Wait Time | 200 milliseconds |
    | Change Wait Time | 0:00:01.500 |</doc>
<shortdoc>To give time for the mainframe screen to be "drawn" and receive the next commands, a "wait time" has been created, which by default is set to 0.5 seconds. This is a sleep applied AFTER the following keywords:</shortdoc>
</kw>
<kw name="Change Wait Time After Write" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\wait_and_timeout.py" lineno="41">
<arguments repr="wait_time_after_write: timedelta">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="wait_time_after_write: timedelta">
<name>wait_time_after_write</name>
<type name="timedelta" typedoc="timedelta">timedelta</type>
</arg>
</arguments>
<doc>To give the user time to see what is happening inside the mainframe, a "wait time after write" has
been created, which by default is set to 0 seconds. This is a sleep applied AFTER sending a string in these
keywords:

- `Write`
- `Write Bare`
- `Write in position`
- `Write Bare in position`

If you want to change this value, just use this keyword passing the time in seconds.

Note: This keyword is useful for debug purpose

Example:
    | Change Wait Time After Write | 1 |
    | Change Wait Time After Write | 0.5 seconds |
    | Change Wait Time After Write | 0:00:02 |</doc>
<shortdoc>To give the user time to see what is happening inside the mainframe, a "wait time after write" has been created, which by default is set to 0 seconds. This is a sleep applied AFTER sending a string in these keywords:</shortdoc>
</kw>
<kw name="Close All Connections" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\connection.py" lineno="206">
<arguments repr="">
</arguments>
<doc>Close all currently opened connections and reset the index counter to 1.</doc>
<shortdoc>Close all currently opened connections and reset the index counter to 1.</shortdoc>
</kw>
<kw name="Close Connection" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\connection.py" lineno="199">
<arguments repr="">
</arguments>
<doc>Close the current connection.</doc>
<shortdoc>Close the current connection.</shortdoc>
</kw>
<kw name="Delete Char" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="25">
<arguments repr="ypos: int | None = None, xpos: int | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ypos: int | None = None">
<name>ypos</name>
<type name="Union" union="true">int | None<type name="int" typedoc="integer">int</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="xpos: int | None = None">
<name>xpos</name>
<type name="Union" union="true">int | None<type name="int" typedoc="integer">int</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Delete the character under the cursor. If you want to delete a character that is in
another position, simply pass the coordinates ``ypos`` / ``xpos``.

Coordinates are 1 based, as listed in the status area of the terminal.

Example:
    | Delete Char |
    | Delete Char | ypos=9 | xpos=25 |</doc>
<shortdoc>Delete the character under the cursor. If you want to delete a character that is in another position, simply pass the coordinates ``ypos`` / ``xpos``.</shortdoc>
</kw>
<kw name="Delete Field" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="40">
<arguments repr="ypos: int | None = None, xpos: int | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ypos: int | None = None">
<name>ypos</name>
<type name="Union" union="true">int | None<type name="int" typedoc="integer">int</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="xpos: int | None = None">
<name>xpos</name>
<type name="Union" union="true">int | None<type name="int" typedoc="integer">int</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Delete the entire content of a field at the current cursor location and positions
the cursor at beginning of field. If you want to delete a field that is in
another position, simply pass the coordinates ``ypos`` / ``xpos`` of any part in the field.

Coordinates are 1 based, as listed in the status area of the terminal.

Example:
    | Delete Field |
    | Delete Field | ypos=12 | xpos=6 |</doc>
<shortdoc>Delete the entire content of a field at the current cursor location and positions the cursor at beginning of field. If you want to delete a field that is in another position, simply pass the coordinates ``ypos`` / ``xpos`` of any part in the field.</shortdoc>
</kw>
<kw name="Execute Command" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="10">
<arguments repr="cmd: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="cmd: str">
<name>cmd</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>Execute a [https://x3270.miraheze.org/wiki/Category:Wc3270_actions|x3270 command].

Example:
    | Execute Command | Enter |
    | Execute Command | Home |
    | Execute Command | Tab |
    | Execute Command | PF(1) |
    | Execute Command | Scroll(backward) | # To send Page Up |
    | Execute Command | Scroll(forward) | # To send Page Down |</doc>
<shortdoc>Execute a [https://x3270.miraheze.org/wiki/Category:Wc3270_actions|x3270 command].</shortdoc>
</kw>
<kw name="Get Current Position" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="88">
<arguments repr="mode: ResultMode = As_Tuple">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mode: ResultMode = As_Tuple">
<name>mode</name>
<type name="ResultMode" typedoc="ResultMode">ResultMode</type>
<default>As_Tuple</default>
</arg>
</arguments>
<doc>Returns the current cursor position. The coordinates are 1 based.

By default, this keyword returns a tuple of integers. However, if you specify the `mode` with the value
``"As Dict"`` (case-insensitive), a dictionary in the form of ``{"xpos": int, "ypos": int}`` is returned.

Example:
    | Get Cursor Position |         | # Returns a position like (1, 1) |
    | Get Cursor Position | As Dict | # Returns a position like {"xpos": 1, "ypos": 1} |</doc>
<shortdoc>Returns the current cursor position. The coordinates are 1 based.</shortdoc>
</kw>
<kw name="Get String Positions" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="45">
<arguments repr="string: str, mode: ResultMode = As_Tuple, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="string: str">
<name>string</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mode: ResultMode = As_Tuple">
<name>mode</name>
<type name="ResultMode" typedoc="ResultMode">ResultMode</type>
<default>As_Tuple</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Returns a list of tuples of ypos and xpos for the position where the `string` was found,
or an empty list if it was not found.

If you specify the `mode` with the value `"As Dict"` (case-insensitive),
a list of dictionaries in the form of ``[{"xpos": int, "ypos": int}]`` is returned.

If `ignore_case` is set to `True`, then the search is done case-insensitively.

Example:
    | ${positions} | Get String Positions | Abc |         | # Returns a list like [(1, 8)] |
    | ${positions} | Get String Positions | Abc | As Dict | # Returns a list like [{"ypos": 1, "xpos": 8}] |</doc>
<shortdoc>Returns a list of tuples of ypos and xpos for the position where the `string` was found, or an empty list if it was not found.</shortdoc>
</kw>
<kw name="Get String Positions Only After" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="62">
<arguments repr="ypos: int, xpos: int, string: str, mode: ResultMode = As_Tuple, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="ypos: int">
<name>ypos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xpos: int">
<name>xpos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="string: str">
<name>string</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mode: ResultMode = As_Tuple">
<name>mode</name>
<type name="ResultMode" typedoc="ResultMode">ResultMode</type>
<default>As_Tuple</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Returns a list of tuples of ypos and xpos for the position where the `string` was found,
but only after the specified ypos/xpos coordinates. If it is not found an empty list is returned.

If you specify the `mode` with the value `"As Dict"` (case-insensitive),
a list of dictionaries in the form of ``[{"xpos": int, "ypos": int}]`` is returned.

If `ignore_case` is set to `True`, then the search is done case-insensitively.

Example:
    | ${positions} | Get String Positions Only After | 5 | 4 | Abc |         | # Returns a list like [(5, 5)] |
    | ${positions} | Get String Positions Only After | 5 | 4 | Abc | As Dict | # Returns a list like [{"ypos": 5, "xpos": 5}] |</doc>
<shortdoc>Returns a list of tuples of ypos and xpos for the position where the `string` was found, but only after the specified ypos/xpos coordinates. If it is not found an empty list is returned.</shortdoc>
</kw>
<kw name="Get String Positions Only Before" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="88">
<arguments repr="ypos: int, xpos: int, string: str, mode: ResultMode = As_Tuple, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="ypos: int">
<name>ypos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xpos: int">
<name>xpos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="string: str">
<name>string</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mode: ResultMode = As_Tuple">
<name>mode</name>
<type name="ResultMode" typedoc="ResultMode">ResultMode</type>
<default>As_Tuple</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Returns a list of tuples of ypos and xpos for the position where the `string` was found,
but only before the specified ypos/xpos coordinates. If it is not found an empty list is returned.

If you specify the `mode` with the value `"As Dict"` (case-insensitive),
a list of dictionaries in the form of ``[{"xpos": int, "ypos": int}]`` is returned.

If `ignore_case` is set to `True`, then the search is done case-insensitively.

Example:
    | ${positions} | Get String Positions Only Before | 11 | 20 | Abc |         | # Returns a list like [(11, 19)] |
    | ${positions} | Get String Positions Only Before | 11 | 20 | Abc | As Dict | # Returns a list like [{"ypos": 11, "xpos": 19}] |</doc>
<shortdoc>Returns a list of tuples of ypos and xpos for the position where the `string` was found, but only before the specified ypos/xpos coordinates. If it is not found an empty list is returned.</shortdoc>
</kw>
<kw name="Move Cursor To" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="103">
<arguments repr="ypos: int, xpos: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="ypos: int">
<name>ypos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xpos: int">
<name>xpos</name>
<type name="int" typedoc="integer">int</type>
</arg>
</arguments>
<doc>Moves the cursor to the specified ypos/xpos position. The coordinates are 1 based.
This keyword raises an error if the specified values exceed the Mainframe screen dimensions.

Example:
    | Move Cursor To | 1 | 5 |</doc>
<shortdoc>Moves the cursor to the specified ypos/xpos position. The coordinates are 1 based. This keyword raises an error if the specified values exceed the Mainframe screen dimensions.</shortdoc>
</kw>
<kw name="Move Next Field" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="64">
<arguments repr="">
</arguments>
<doc>Move the cursor to the next input field. Equivalent to pressing the Tab key.</doc>
<shortdoc>Move the cursor to the next input field. Equivalent to pressing the Tab key.</shortdoc>
</kw>
<kw name="Move Previous Field" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="71">
<arguments repr="">
</arguments>
<doc>Move the cursor to the previous input field. Equivalent to pressing the Shift+Tab keys.</doc>
<shortdoc>Move the cursor to the previous input field. Equivalent to pressing the Shift+Tab keys.</shortdoc>
</kw>
<kw name="Open Connection" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\connection.py" lineno="14">
<arguments repr="host: str, LU: str | None = None, port: int = 23, extra_args: List[str] | PathLike | None = None, alias: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="host: str">
<name>host</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="LU: str | None = None">
<name>LU</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="port: int = 23">
<name>port</name>
<type name="int" typedoc="integer">int</type>
<default>23</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="extra_args: List[str] | PathLike | None = None">
<name>extra_args</name>
<type name="Union" union="true">List[str] | PathLike | None<type name="List" typedoc="list">List[str]<type name="str" typedoc="string">str</type></type><type name="PathLike" typedoc="Path">PathLike</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="alias: str | None = None">
<name>alias</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Create a connection to an IBM3270 mainframe with the default port 23.
To establish a connection, only the hostname is required.
Optional parameters include logical unit name (LU) and port.

Additional configuration data can be provided through the `extra_args` parameter.
`extra_args` accepts either a list or a path
to a file containing [https://x3270.miraheze.org/wiki/Category:Command-line_options|x3270 command line options].

Entries in the argfile can be on one line or multiple lines. Lines starting with "#" are considered comments.
Arguments containing whitespace must be enclosed in single or double quotes.

| # example_argfile_oneline.txt
| -accepthostname myhost.com

| # example_argfile_multiline.txt
| -xrm "wc3270.acceptHostname: myhost.com"
| # this is a comment
| -charset french
| -port 992

Please ensure that the arguments provided are available for your specific x3270 application and version.
Refer to the [https://x3270.miraheze.org/wiki/Wc3270/Command-line_options|wc3270 command line options]
for a subset of available options.

Note: If you specify the port with the `-port` command-line option in `extra_args`
(or use the -xrm resource command for it), it will take precedence over the `port` argument provided
in the `Open Connection` keyword.

This keyword returns the index of the opened connection, which can be used to reference the connection
when switching between connections using the `Switch Connection` keyword. For more information on opening
and switching between multiple connections, please refer to the `Concurrent Connections` section.

Example:
    | Open Connection | Hostname |
    | Open Connection | Hostname | LU=LUname |
    | Open Connection | Hostname | port=992 |
    | @{extra_args}   | Create List | -accepthostname | myhost.com | -cafile | ${CURDIR}/cafile.crt |
    | Append To List  | ${extra_args} | -port | 992 |
    | Open Connection | Hostname | extra_args=${extra_args} |
    | Open Connection | Hostname | extra_args=${CURDIR}/argfile.txt |
    | Open Connection | Hostname | alias=my_first_connection |</doc>
<shortdoc>Create a connection to an IBM3270 mainframe with the default port 23. To establish a connection, only the hostname is required. Optional parameters include logical unit name (LU) and port.</shortdoc>
</kw>
<kw name="Open Connection From Session File" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\connection.py" lineno="118">
<arguments repr="session_file: PathLike, alias: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="session_file: PathLike">
<name>session_file</name>
<type name="PathLike" typedoc="Path">PathLike</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="alias: str | None = None">
<name>alias</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Create a connection to an IBM3270 mainframe
using a [https://x3270.miraheze.org/wiki/Session_file|session file].

The session file contains [https://x3270.miraheze.org/wiki/Category:Resources|resources (settings)]
for a specific host session.

The only mandatory setting required to establish the connection
is the [https://x3270.miraheze.org/wiki/Hostname_resource|hostname resource].

This keyword is an alternative to `Open Connection`. Please note that the Robot-Framework-Mainframe-3270-Library
currently only supports model "2". Specifying any other model will result in a failure.

For more information on session file syntax and detailed examples, please
consult the [https://x3270.miraheze.org/wiki/Session_file|x3270 wiki].

This keyword returns the index of the opened connection, which can be used to reference the connection
when switching between connections using the `Switch Connection` keyword. For more information on opening and
switching between multiple connections, please refer to the `Concurrent Connections` section.

Example:
| Open Connection From Session File | ${CURDIR}/session.wc3270 |

where the content of `session.wc3270` is:
| wc3270.hostname: myhost.com:23
| wc3270.model: 2</doc>
<shortdoc>Create a connection to an IBM3270 mainframe using a [https://x3270.miraheze.org/wiki/Session_file|session file].</shortdoc>
</kw>
<kw name="Page Should Contain All Strings" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="115">
<arguments repr="list_string: List[str], ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="list_string: List[str]">
<name>list_string</name>
<type name="List" typedoc="list">List[str]<type name="str" typedoc="string">str</type></type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Assert that all the strings in a given list exist on the mainframe screen.

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Contain All Strings | ${list_of_string} |
    | Page Should Contain All Strings | ${list_of_string} | ignore_case=True |
    | Page Should Contain All Strings | ${list_of_string} | error_message=New error message |</doc>
<shortdoc>Assert that all the strings in a given list exist on the mainframe screen.</shortdoc>
</kw>
<kw name="Page Should Contain Any String" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="62">
<arguments repr="list_string: List[str], ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="list_string: List[str]">
<name>list_string</name>
<type name="List" typedoc="list">List[str]<type name="str" typedoc="string">str</type></type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Assert that one of the strings in a given list exists on the mainframe screen.

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Contain Any String | ${list_of_string} |
    | Page Should Contain Any String | ${list_of_string} | ignore_case=True |
    | Page Should Contain Any String | ${list_of_string} | error_message=New error message |</doc>
<shortdoc>Assert that one of the strings in a given list exists on the mainframe screen.</shortdoc>
</kw>
<kw name="Page Should Contain Match" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="227">
<arguments repr="txt: str, ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Assert that the text displayed on the mainframe screen matches the given pattern.

Pattern matching is similar to matching files in a shell, and it is always case-sensitive.
In the pattern, * matches anything and ? matches any single character.

Note that for this keyword the entire screen is considered a string. So if you want to search
for the string "something" and it is somewhere other than at the beginning or end of the screen, it
should be reported as follows: **something**

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Contain Match | **something** |
    | Page Should Contain Match | **so???hing** |
    | Page Should Contain Match | **someTHING** | ignore_case=True |
    | Page Should Contain Match | **something** | error_message=New error message |</doc>
<shortdoc>Assert that the text displayed on the mainframe screen matches the given pattern.</shortdoc>
</kw>
<kw name="Page Should Contain String" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="11">
<arguments repr="txt: str, ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Assert that a given string exists on the mainframe screen.

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Contain String | something |
    | Page Should Contain String | someTHING | ignore_case=True |
    | Page Should Contain String | something | error_message=New error message |</doc>
<shortdoc>Assert that a given string exists on the mainframe screen.</shortdoc>
</kw>
<kw name="Page Should Contain String X Times" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="166">
<arguments repr="txt: str, number: int, ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="number: int">
<name>number</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Asserts that the entered string appears the desired number of times on the mainframe screen.

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
       | Page Should Contain String X Times | something | 3 |
       | Page Should Contain String X Times | someTHING | 3 | ignore_case=True |
       | Page Should Contain String X Times | something | 3 | error_message=New error message |</doc>
<shortdoc>Asserts that the entered string appears the desired number of times on the mainframe screen.</shortdoc>
</kw>
<kw name="Page Should Match Regex" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="199">
<arguments repr="regex_pattern: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="regex_pattern: str">
<name>regex_pattern</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>Fails if string does not match pattern as a regular expression. Regular expression check is
implemented using the Python [https://docs.python.org/2/library/re.html|re module]. Python's
regular expression syntax is derived from Perl, and it is thus also very similar to the syntax used,
for example, in Java, Ruby and .NET.

Backslash is an escape character in the test data, and possible backslashes in the pattern must
thus be escaped with another backslash (e.g. \\d\\w+).</doc>
<shortdoc>Fails if string does not match pattern as a regular expression. Regular expression check is implemented using the Python [https://docs.python.org/2/library/re.html|re module]. Python's regular expression syntax is derived from Perl, and it is thus also very similar to the syntax used, for example, in Java, Ruby and .NET.</shortdoc>
</kw>
<kw name="Page Should Not Contain All Strings" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="136">
<arguments repr="list_string: List[str], ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="list_string: List[str]">
<name>list_string</name>
<type name="List" typedoc="list">List[str]<type name="str" typedoc="string">str</type></type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Fails if one of the strings in a given list exists on the mainframe screen. If one of the string
are found, the keyword will raise an exception.

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Not Contain All Strings | ${list_of_string} |
    | Page Should Not Contain All Strings | ${list_of_string} | ignore_case=True |
    | Page Should Not Contain All Strings | ${list_of_string} | error_message=New error message |</doc>
<shortdoc>Fails if one of the strings in a given list exists on the mainframe screen. If one of the string are found, the keyword will raise an exception.</shortdoc>
</kw>
<kw name="Page Should Not Contain Any String" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="93">
<arguments repr="list_string: List[str], ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="list_string: List[str]">
<name>list_string</name>
<type name="List" typedoc="list">List[str]<type name="str" typedoc="string">str</type></type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Assert that none of the strings in a given list exists on the mainframe screen. If one or more of the
string are found, the keyword will raise an exception.

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Not Contain Any Strings | ${list_of_string} |
    | Page Should Not Contain Any Strings | ${list_of_string} | ignore_case=True |
    | Page Should Not Contain Any Strings | ${list_of_string} | error_message=New error message |</doc>
<shortdoc>Assert that none of the strings in a given list exists on the mainframe screen. If one or more of the string are found, the keyword will raise an exception.</shortdoc>
</kw>
<kw name="Page Should Not Contain Match" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="263">
<arguments repr="txt: str, ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Assert that the text displayed on the mainframe screen does NOT match the given pattern.

Pattern matching is similar to matching files in a shell, and it is always case-sensitive.
In the pattern, * matches anything and ? matches any single character.

Note that for this keyword the entire screen is considered a string. So if you want to search
for the string "something" and it is somewhere other than at the beginning or end of the screen, it
should be reported as follows: **something**

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Not Contain Match | **something** |
    | Page Should Not Contain Match | **so???hing** |
    | Page Should Not Contain Match | **someTHING** | ignore_case=True |
    | Page Should Not Contain Match | **something** | error_message=New error message |</doc>
<shortdoc>Assert that the text displayed on the mainframe screen does NOT match the given pattern.</shortdoc>
</kw>
<kw name="Page Should Not Contain String" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="37">
<arguments repr="txt: str, ignore_case: bool = False, error_message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type name="bool" typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error_message: str | None = None">
<name>error_message</name>
<type name="Union" union="true">str | None<type name="str" typedoc="string">str</type><type name="None" typedoc="None">None</type></type>
<default>None</default>
</arg>
</arguments>
<doc>Assert that a given string does NOT exist on the mainframe screen.

The assertion is case-sensitive. If you want it to be case-insensitive, you can pass the argument
ignore_case=True.

You can change the exception message by setting a custom string to error_message.

Example:
    | Page Should Not Contain String | something |
    | Page Should Not Contain String | someTHING | ignore_case=True |
    | Page Should Not Contain String | something | error_message=New error message |</doc>
<shortdoc>Assert that a given string does NOT exist on the mainframe screen.</shortdoc>
</kw>
<kw name="Page Should Not Match Regex" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\assertions.py" lineno="213">
<arguments repr="regex_pattern: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="regex_pattern: str">
<name>regex_pattern</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>Fails if string does match pattern as a regular expression. Regular expression check is
implemented using the Python [https://docs.python.org/2/library/re.html|re module]. Python's
regular expression syntax is derived from Perl, and it is thus also very similar to the syntax used,
for example, in Java, Ruby and .NET.

Backslash is an escape character in the test data, and possible backslashes in the pattern must
thus be escaped with another backslash (e.g. \\d\\w+).</doc>
<shortdoc>Fails if string does match pattern as a regular expression. Regular expression check is implemented using the Python [https://docs.python.org/2/library/re.html|re module]. Python's regular expression syntax is derived from Perl, and it is thus also very similar to the syntax used, for example, in Java, Ruby and .NET.</shortdoc>
</kw>
<kw name="Read" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="10">
<arguments repr="ypos: int, xpos: int, length: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="ypos: int">
<name>ypos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xpos: int">
<name>xpos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="length: int">
<name>length</name>
<type name="int" typedoc="integer">int</type>
</arg>
</arguments>
<doc>Get a string of ``length`` at screen coordinates ``ypos`` / ``xpos``.

Coordinates are 1 based, as listed in the status area of the terminal.

Example for read a string in the position y=8 / x=10 of a length 15:
    | ${value} | Read | 8 | 10 | 15 |</doc>
<shortdoc>Get a string of ``length`` at screen coordinates ``ypos`` / ``xpos``.</shortdoc>
</kw>
<kw name="Read All Screen" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="28">
<arguments repr="">
</arguments>
<doc>Read the current screen and returns all content in one string.

This is useful if your automation scripts should take different routes depending
on a message shown on the screen.

Example:
    | ${screen} | Read All Screen |
    | IF | 'certain text' in '''${screen}''' |
    | | Do Something |
    | ELSE | |
    | | Do Something Else |
    | END | |</doc>
<shortdoc>Read the current screen and returns all content in one string.</shortdoc>
</kw>
<kw name="Read From Current Position" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="21">
<arguments repr="length: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="length: int">
<name>length</name>
<type name="int" typedoc="integer">int</type>
</arg>
</arguments>
<doc>Similar to `Read`, however this keyword only takes `length` as an argument
to get a string of length from the current cursor position.</doc>
<shortdoc>Similar to `Read`, however this keyword only takes `length` as an argument to get a string of length from the current cursor position.</shortdoc>
</kw>
<kw name="Register Run On Failure Keyword" lineno="177">
<arguments repr="keyword: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="keyword: str">
<name>keyword</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>This keyword lets you change the keyword that runs on failure during test execution.
The default is `Take Screenshot`, which is set on library import.

You can set ``None`` to this keyword, if you do not want to run any keyword on failure.

Example:
    | Register Run On Failure Keyword | None | # no keyword is run on failure |
    | Register Run On Failure Keyword | Custom Keyword | # Custom Keyword is run on failure |</doc>
<shortdoc>This keyword lets you change the keyword that runs on failure during test execution. The default is `Take Screenshot`, which is set on library import.</shortdoc>
</kw>
<kw name="Send Enter" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="56">
<arguments repr="">
</arguments>
<doc>Send an Enter to the screen.</doc>
<shortdoc>Send an Enter to the screen.</shortdoc>
</kw>
<kw name="Send PF" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\commands.py" lineno="78">
<arguments repr="pf: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="pf: str">
<name>pf</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>Send a Program Function to the screen.

Example:
    | Send PF | 3 |</doc>
<shortdoc>Send a Program Function to the screen.</shortdoc>
</kw>
<kw name="Set Screenshot Folder" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\screenshot.py" lineno="10">
<arguments repr="path: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: str">
<name>path</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>Set a folder to keep the html files generated by the `Take Screenshot` keyword.

Note that the folder needs to exist before running your automation scripts. Else the images
will be stored in the ``${OUTPUT DIR}`` set by robotframework.

Example:
    | Set Screenshot Folder | C:\\Temp\\Images |</doc>
<shortdoc>Set a folder to keep the html files generated by the `Take Screenshot` keyword.</shortdoc>
</kw>
<kw name="Switch Connection" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\connection.py" lineno="183">
<arguments repr="alias_or_index: str | int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="alias_or_index: str | int">
<name>alias_or_index</name>
<type name="Union" union="true">str | int<type name="str" typedoc="string">str</type><type name="int" typedoc="integer">int</type></type>
</arg>
</arguments>
<doc>Switch the current connection to the one identified by index or alias. Indices are returned from
and aliases can be optionally provided to the `Open Connection` and `Open Connection From Session File`
keywords.

For more information on opening and switching between multiple connections,
please refer to the `Concurrent Connections` section.

Examples:
| Open Connection | Hostname | alias=first |
| Open Connection | Hostname | alias=second | # second is now the current connection |
| Switch Connection | first | | # first is now the current connection  |</doc>
<shortdoc>Switch the current connection to the one identified by index or alias. Indices are returned from and aliases can be optionally provided to the `Open Connection` and `Open Connection From Session File` keywords.</shortdoc>
</kw>
<kw name="Take Screenshot" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\screenshot.py" lineno="26">
<arguments repr="height: int = 410, width: int = 670, filename_prefix: str = screenshot">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="height: int = 410">
<name>height</name>
<type name="int" typedoc="integer">int</type>
<default>410</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="width: int = 670">
<name>width</name>
<type name="int" typedoc="integer">int</type>
<default>670</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="filename_prefix: str = screenshot">
<name>filename_prefix</name>
<type name="str" typedoc="string">str</type>
<default>screenshot</default>
</arg>
</arguments>
<doc>Generate a screenshot of the IBM 3270 Mainframe in a html format. The
default folder is the log folder of RobotFramework, if you want change see the `Set Screenshot Folder`.

The Screenshot is printed in an iframe log, with the values of height=410 and width=670, you
can change these values by passing them to the keyword.

The file name prefix can be set, the default is "screenshot".

The full file path is returned.

Example:
    | ${filepath} | Take Screenshot |
    | ${filepath} | Take Screenshot | height=500 | width=700 |
    | Take Screenshot | height=500 | width=700 |
    | Take Screenshot | filename_prefix=MyScreenshot |</doc>
<shortdoc>Generate a screenshot of the IBM 3270 Mainframe in a html format. The default folder is the log folder of RobotFramework, if you want change see the `Set Screenshot Folder`.</shortdoc>
</kw>
<kw name="Wait Field Detected" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\wait_and_timeout.py" lineno="63">
<arguments repr="">
</arguments>
<doc>Wait until the screen is ready, the cursor has been positioned
on a modifiable field, and the keyboard is unlocked.

Sometimes the server will "unlock" the keyboard but the screen
will not yet be ready.  In that case, an attempt to read or write to the
screen will result in a 'E' keyboard status because we tried to read from
a screen that is not ready yet.

Using this method tells the client to wait until a field is
detected and the cursor has been positioned on it.</doc>
<shortdoc>Wait until the screen is ready, the cursor has been positioned on a modifiable field, and the keyboard is unlocked.</shortdoc>
</kw>
<kw name="Wait Until String" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\wait_and_timeout.py" lineno="78">
<arguments repr="txt: str, timeout: timedelta = 0:00:05">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta = 0:00:05">
<name>timeout</name>
<type name="timedelta" typedoc="timedelta">timedelta</type>
<default>0:00:05</default>
</arg>
</arguments>
<doc>Wait until a string exists on the mainframe screen to perform the next step. If the string does not appear
in 5 seconds, the keyword will raise an exception. You can define a different timeout.

Example:
    | Wait Until String | something |
    | Wait Until String | something | 10 |
    | Wait Until String | something | 15 s |
    | Wait Until String | something | 0:00:15 |</doc>
<shortdoc>Wait until a string exists on the mainframe screen to perform the next step. If the string does not appear in 5 seconds, the keyword will raise an exception. You can define a different timeout.</shortdoc>
</kw>
<kw name="Write" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="114">
<arguments repr="txt: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>Send a string *and Enter* to the screen at the current cursor location.

Example:
    | Write | something |</doc>
<shortdoc>Send a string *and Enter* to the screen at the current cursor location.</shortdoc>
</kw>
<kw name="Write Bare" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="123">
<arguments repr="txt: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
</arguments>
<doc>Send only the string to the screen at the current cursor location.

Example:
    | Write Bare | something |</doc>
<shortdoc>Send only the string to the screen at the current cursor location.</shortdoc>
</kw>
<kw name="Write Bare In Position" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="144">
<arguments repr="txt: str, ypos: int, xpos: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="ypos: int">
<name>ypos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xpos: int">
<name>xpos</name>
<type name="int" typedoc="integer">int</type>
</arg>
</arguments>
<doc>Send only the string to the screen at screen coordinates ``ypos`` / ``xpos``.

Coordinates are 1 based, as listed in the status area of the
terminal.

Example:
    | Write Bare in Position | something | 9 | 11 |</doc>
<shortdoc>Send only the string to the screen at screen coordinates ``ypos`` / ``xpos``.</shortdoc>
</kw>
<kw name="Write In Position" source="C:\Repos\Robot-Framework-Mainframe-3270\Mainframe3270\keywords\read_write.py" lineno="132">
<arguments repr="txt: str, ypos: int, xpos: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="txt: str">
<name>txt</name>
<type name="str" typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="ypos: int">
<name>ypos</name>
<type name="int" typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xpos: int">
<name>xpos</name>
<type name="int" typedoc="integer">int</type>
</arg>
</arguments>
<doc>Send a string *and Enter* to the screen at screen coordinates ``ypos`` / ``xpos``.

Coordinates are 1 based, as listed in the status area of the
terminal.

Example:
    | Write in Position | something | 9 | 11 |</doc>
<shortdoc>Send a string *and Enter* to the screen at screen coordinates ``ypos`` / ``xpos``.</shortdoc>
</kw>
</keywords>
<datatypes>
<enums>
<enum name="ResultMode">
<doc>An enumeration.</doc>
<members>
<member name="As_Tuple" value="1"/>
<member name="As_Dict" value="2"/>
</members>
</enum>
</enums>
</datatypes>
<typedocs>
<type name="boolean" type="Standard">
<doc>Strings ``TRUE``, ``YES``, ``ON`` and ``1`` are converted to Boolean ``True``,
the empty string as well as strings ``FALSE``, ``NO``, ``OFF`` and ``0``
are converted to Boolean ``False``, and the string ``NONE`` is converted
to the Python ``None`` object. Other strings and other accepted values are
passed as-is, allowing keywords to handle them specially if
needed. All string comparisons are case-insensitive.

Examples: ``TRUE`` (converted to ``True``), ``off`` (converted to ``False``),
``example`` (used as-is)
</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
<type>None</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Get String Positions</usage>
<usage>Get String Positions Only After</usage>
<usage>Get String Positions Only Before</usage>
<usage>Page Should Contain All Strings</usage>
<usage>Page Should Contain Any String</usage>
<usage>Page Should Contain Match</usage>
<usage>Page Should Contain String</usage>
<usage>Page Should Contain String X Times</usage>
<usage>Page Should Not Contain All Strings</usage>
<usage>Page Should Not Contain Any String</usage>
<usage>Page Should Not Contain Match</usage>
<usage>Page Should Not Contain String</usage>
</usages>
</type>
<type name="integer" type="Standard">
<doc>Conversion is done using Python's [https://docs.python.org/library/functions.html#int|int]
built-in function. Floating point
numbers are accepted only if they can be represented as integers exactly.
For example, ``1.0`` is accepted and ``1.1`` is not.

Starting from RF 4.1, it is possible to use hexadecimal, octal and binary
numbers by prefixing values with ``0x``, ``0o`` and ``0b``, respectively.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``42``, ``-1``, ``0b1010``, ``10 000 000``, ``0xBAD_C0FFEE``
</doc>
<accepts>
<type>string</type>
<type>float</type>
</accepts>
<usages>
<usage>Delete Char</usage>
<usage>Delete Field</usage>
<usage>Get String Positions Only After</usage>
<usage>Get String Positions Only Before</usage>
<usage>Move Cursor To</usage>
<usage>Open Connection</usage>
<usage>Page Should Contain String X Times</usage>
<usage>Read</usage>
<usage>Read From Current Position</usage>
<usage>Switch Connection</usage>
<usage>Take Screenshot</usage>
<usage>Write Bare In Position</usage>
<usage>Write In Position</usage>
</usages>
</type>
<type name="list" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#list|list]
literals. They are converted to actual lists using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
lists and other containers.

If the type has nested types like ``list[int]``, items are converted
to those types automatically. This in new in Robot Framework 6.0.

Examples: ``['one', 'two']``, ``[('one', 1), ('two', 2)]``
</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>Open Connection</usage>
<usage>Page Should Contain All Strings</usage>
<usage>Page Should Contain Any String</usage>
<usage>Page Should Not Contain All Strings</usage>
<usage>Page Should Not Contain Any String</usage>
</usages>
</type>
<type name="None" type="Standard">
<doc>String ``NONE`` (case-insensitive) is converted to Python ``None`` object.
Other values cause an error.
</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>Delete Char</usage>
<usage>Delete Field</usage>
<usage>Open Connection</usage>
<usage>Open Connection From Session File</usage>
<usage>Page Should Contain All Strings</usage>
<usage>Page Should Contain Any String</usage>
<usage>Page Should Contain Match</usage>
<usage>Page Should Contain String</usage>
<usage>Page Should Contain String X Times</usage>
<usage>Page Should Not Contain All Strings</usage>
<usage>Page Should Not Contain Any String</usage>
<usage>Page Should Not Contain Match</usage>
<usage>Page Should Not Contain String</usage>
</usages>
</type>
<type name="Path" type="Standard">
<doc>Strings are converted [https://docs.python.org/library/pathlib.html|Path] objects.
On Windows ``/`` is converted to ``\`` automatically.

Examples: ``/tmp/absolute/path``, ``relative/path/to/file.ext``, ``name.txt``
</doc>
<accepts>
<type>string</type>
<type>PurePath</type>
</accepts>
<usages>
<usage>Open Connection</usage>
<usage>Open Connection From Session File</usage>
</usages>
</type>
<type name="ResultMode" type="Enum">
<doc>An enumeration.</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>Get Current Position</usage>
<usage>Get String Positions</usage>
<usage>Get String Positions Only After</usage>
<usage>Get String Positions Only Before</usage>
</usages>
<members>
<member name="As_Tuple" value="1"/>
<member name="As_Dict" value="2"/>
</members>
</type>
<type name="string" type="Standard">
<doc>All arguments are converted to Unicode strings.</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Execute Command</usage>
<usage>Get String Positions</usage>
<usage>Get String Positions Only After</usage>
<usage>Get String Positions Only Before</usage>
<usage>Open Connection</usage>
<usage>Open Connection From Session File</usage>
<usage>Page Should Contain All Strings</usage>
<usage>Page Should Contain Any String</usage>
<usage>Page Should Contain Match</usage>
<usage>Page Should Contain String</usage>
<usage>Page Should Contain String X Times</usage>
<usage>Page Should Match Regex</usage>
<usage>Page Should Not Contain All Strings</usage>
<usage>Page Should Not Contain Any String</usage>
<usage>Page Should Not Contain Match</usage>
<usage>Page Should Not Contain String</usage>
<usage>Page Should Not Match Regex</usage>
<usage>Register Run On Failure Keyword</usage>
<usage>Send PF</usage>
<usage>Set Screenshot Folder</usage>
<usage>Switch Connection</usage>
<usage>Take Screenshot</usage>
<usage>Wait Until String</usage>
<usage>Write</usage>
<usage>Write Bare</usage>
<usage>Write Bare In Position</usage>
<usage>Write In Position</usage>
</usages>
</type>
<type name="timedelta" type="Standard">
<doc>Strings are expected to represent a time interval in one of
the time formats Robot Framework supports:
- a number representing seconds like ``42`` or ``10.5``
- a time string like ``1 hour 2 seconds`` or ``1h 2s``
- a "timer" string like ``01:02`` (1 minute 2 seconds) or ``01:00:03`` (1 hour 3 seconds)

Integers and floats are considered to be seconds.

See the [https://robotframework.org/robotframework/|Robot Framework User Guide]
for more details about the supported time formats.
</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Change Timeout</usage>
<usage>Change Wait Time</usage>
<usage>Change Wait Time After Write</usage>
<usage>Wait Until String</usage>
</usages>
</type>
</typedocs>
</keywordspec>
